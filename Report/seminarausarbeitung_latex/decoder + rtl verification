Instruction decoder

The instruction decoder generates all necessary control signals for the execution stage (register file, alu, memory controller, multiplexers, flag updater). The instructions have different formats that are characterized by specific bit patterns in the instruction bitstring. The instruction decoder tests the instruction againts these bit patterns to recognize the instrution format and extract the instruction parameters (alu operation, operation sources and target).

It can decode all instructions on the "Thumb 16-bit Instruction Set Quick Reference Card" except the CBNZ and CBZ instructions, for which there was no time left to implement them, and the instructions in the "Processor state change" and "Hints" sections which should not be implemented. Also, the change to ARM state is not implemented because the processor can only work in Thumb mode.

For operations that access the memory or the program counter, it stalls the instruction fetch to prevent interfering with the memory access of the execution stage or using a wrong program counter value for fetching a new instruction. 

Instructions that can not be executed in one step are split into multiple smaller steps. This is the case for the instructions PUSH, POP, LDMIA and STMIA because they can store or load up to eight values in the memory, and for the BL instruction because the execution of its second part needs three consecutive alu operations on registers. During the execution of the steps of a split instruction, the instruction fetch ist stalled by the decoder.

For the split of the instructions, a step register is used which masks the already executed steps with zeros. A one-hot-encoding was chosen instead of binary encoding to allow using a part of the instruction bitstring as a selector for the steps to execute (e. g. for bits [7:0] = 1000 0001 of an STMIA instruction, only the steps "store register R0" and "store register R7" are executed and after the first step, the step register ist set to 1111_1110 to mask bit 0 which corresponds to the first step).

For the conditional execution of up to four instructions in an IT block, a register "itstate" is used that stores the execution condition for up to four instructions. The following instructions which are subject to the execution condition are executed only if the correspondig condition is true. Otherwise a NOP ist executed. This register is set when an IT instruction is executed and shifts left with every following instruction until all execution coditions loaded by the IT instruction are shifted out. Then it is reset to zero. 


In retrospect, it would have been better to place the logic for conditional execution in the instruction fetch module because it would have been possible to fetch only the instructions that are really executed. That logic would have needed the capability to identify CMP instructions because they update the condition flags which are used to determine if an instruction is executed or not despite being in an IT block and could have altered the instructions to fetch. Other instructions that normally update the condition flags do not do so when in an IT block.

The decoder also has two outputs that control two multiplexers in the two operand paths to the alu. they can select modified versions of the operands as inputs to the alu which are used for some instructions, e. g. REV16 or REVSH.


RTL verification

The testbench for the register transfer level verification of count32 and memcpy46 sample test programs consists of the memory module and the cpu top module. The clock and reset signals are generated in the testbench module. The cpu module reads the instructions from the memory module, which is loaded with the initial date for the sample programs, and also saves the results of the program execustions in the memory.

In earlier stages of development, testbenches for the modules were used. After the modules were written and tested, they were integrated into the top module one by one and tested together. Before the integration of the instruction fetch module, the decoder and execution stage were tested together with different complicated instructions like IT, LDMIA and STMIA. The instructions were asserted directly in the testbench. The hex codes for the test programs were generated by the GNU ARM assembler which translated the written assembler test programs to the hex codes needed in the testbenches. C programs were unsuited for the testing at this stage because they did not necessarily generate the exact instruction sequences desired.





